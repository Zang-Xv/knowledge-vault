# 服务器管理

鉴于服务器的使用越来越多，有一些最好遵守的管理和使用方式，探究和记录在此
附带了很多关于 linux 的探索, 活没干, 各种方面的知识倒是看了很多
不知道是不是应该另外开一个页面用来记录 linux 相关的知识?

## 系统盘和数据盘

为了复用性和安全性，服务器也需要像pc一般区分不同的盘, 以便能够备份重装等等
但是 linux 的系统又没有明确直接的盘符, 这容易叫人迷惑
首先说明系统盘和数据盘依旧只是个人使用上的区分, 是为了复用性和数据安全产生的用法

### 如何区分有多少块云硬盘

`lsblk`是 list block devices 的缩写
用来查看当前系统中的块设备（磁盘、分区、虚拟盘）及其挂载情况。

```bash
root@xxx:~# lsblk
NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
vda    252:0    0   90G  0 disk
├─vda1 252:1    0  200M  0 part /boot/efi  
└─vda2 252:2    0 89.8G  0 part /
vdb    252:16   0  120G  0 disk
```

其中的 `vda`, `vdb`就是两块云硬盘, VirtIO Disk a/b, 这种命名是由于 VirtIO 是比较成熟的储存虚拟化方案, 如果在 wsl 中的话设备则不会这样命名, 命名法则姑且不论
这里姑且先探究这个挂载两个云硬盘的服务器

`vda`是系统盘, 已经挂载到根目录, 同时还分有一个 200M 的引导分区, 和实际硬盘相似

#### 分区和挂载流程

给 vdb 分区（推荐，但不是必须）
`sudo parted /dev/vdb --script mklabel gpt mkpart primary ext4 0% 100%`
parted: GNU 分区工具
--script: 非交互模式(自动yes并持续执行)
mklabel gpt(GUID Partition Table): 建立“磁盘分区表”
mkpart primary ext4: 创建一个分区, 主分区, 标注格式为ext4, 分区空间从0-100

`fdisk /dev/vdb`
fdisk: 老牌分区工具, 仅支持 MBR 或 GPT 分区表, 操作没有parted那么精细
n -> 新分区
t -> 类型
w -> 写入

完成后:

```bash
vdb
└─vdb1
```

```bash
# 格式化为 ext4: 
sudo mkfs.ext4 /dev/vdb1
# 创建挂载目录: 
sudo mkdir /data
# 临时挂载（立即可用）: 
sudo mount /dev/vdb1 /data
```

验证：`df -h`或`lsblk`
你会看到类似：`/dev/vdb1   120G   ...   /data`
但是此时挂载只在该开机周期内有效, 服务器关机重启后需要手动再次挂载

设置开机自动挂载

```bash
# 获取 UUID：
blkid /dev/vdb1
# 输出 UUID="d6cfad39-fecf-4376-90ab-bf837087279b" ...

# 编辑 /etc/fstab：
sudo nano /etc/fstab

# 加一行：
# UUID=xxxx-xxxx-xxxx  /data  ext4  defaults,nofail  0  2
# <设备> <挂载点> <文件系统类型> <挂载选项> <是否dump备份(古早备份方式, 现在一般不用)> <pass(开机磁盘检查顺序)>

# 测试：无报错 = 成功
sudo mount -a
```

用户通过软链接指向并访问数据盘

```bash
# 创建软连接
ln -s /data /home/xxx/data

# 可以直接访问
cd ~/data/datasets
```

虽然此时可以直接访问, 但是只能读不能写, 因为此时的用户大概是没有权限的
个人使用的情况下直接把`/data`的所有者换成普通用户即可, 折腾权限管理什么比较麻烦, 个人使用不太需要

```bash
# 查看数据盘的所有者和访问权限
ls -ld /data
drwxr-xr-x 3 root root 4096 Jan 16 20:21 /data

# 更改所有者
sudo chown -R dev:dev /data
ls -ld /data
drwxr-xr-x 3 dev dev 4096 Jan 16 20:21 /data
```

### 扩容云硬盘

有时候会需要对云硬盘进行扩容, 但是硬盘中的多个分区并不会自动接力储存, 而是会报错, 甚至无法挂载到同一目录下, 后一次挂载会覆盖前一次
如果要把新扩容的空间合并到原有的空间有几个办法
按照不同的情况可以选用不同的方式

#### 直接扩容

**前提**: 格式化之前没有分区, 是整盘直挂

这是比较省心省事的做法, 如果没有分区的话, 只需要 resize 就可以自动吃掉新空间
执行`resize2fs /dev/vdb`即可

#### 合并为同一分区

**前提**: 若已经进行了分区, 前后空间连续时可以吞掉后面的未分配空间
这实际上和 win 的硬盘分区也是相似的
**注意**: win 上是无法对硬盘分区前端进行修改的, 但是 linux 可以, 如果修改了分区前端会将文件内容错误地识别成为 inode , 如果未触发读写或系统的自动校正, 改回去还能够复原, 但一旦触发文件就会损坏无法复原

##### 1. 卸载分区(可选)

离线操作永远比在线安全

解除挂载`umount /data`, 如果提示 busy，用: `lsof +D /data`查找打开的文件, `+D`递归搜索目录及其子目录
输出类似于:

```bash
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME
bash    1285 root  cwd    DIR 252,17     4096 1835009 /data/chartspark
lsof    3361 root  cwd    DIR 252,17     4096 1835009 /data/chartspark
lsof    3362 root  cwd    DIR 252,17     4096 1835009 /data/chartspark
```

**注意**: 被打开作为当前工作目录(cwd)也会导致busy

强制卸载方法:
`umount -f /data`, -f强制卸载
可能导致：进程异常, 数据未 flush, 文件损坏
`umount -l /data`, `-l = lazy umount`等进程自己退出才真正卸载风险比 -f 小

##### 2. 扩大分区

使用工具：`growpart /dev/vdb 1`不容易犯错, 它会自动把分区拓展到空闲空间末尾, 不会乱动到分区前端
其中`/dev/vdb`是设备名, `1`是分区号
接着验证分区是否变大`lsblk`, 如果没有增长的话使用`partprobe /dev/vdb`让内核重新读取分区表
输出: `CHANGED: partition=1 start=2048 old: size=251654144 end=251656192 new: size=419428319 end=419430367`

##### 3. 扩展文件系统

对 ext4：`resize2fs /dev/vdb1`
如果不对文件系统进行扩展的话, 即使分区变大了储存空间也并没有变大
可以通过挂载后使用`df -h /data`查看
最后如果卸载了硬盘需要重新挂载并确认是否成功

#### 使用 LVM 合并分区为 逻辑卷

**前提**: 需要提前进行处理, 引入 LVM 会覆写原有文件

LVM 把事情抽象并拆成 3 层：`物理分区(PV) → 卷组(VG) → 逻辑卷(LV)`
标记 PV 的时候会清空该分区, 这是因为 LVM 需要在磁盘头部写 metadata, 甚至会覆盖原有文件系统结构
扩容 VG 和 LV 则不需要, 所以使用 LVM 可以很方便地移来接去

##### 1.磁盘分区(可选但推荐)

LVM 是可以直接把一整块磁盘当作 PV 管理的, 所以可以不分区

`fdisk /dev/vdb`
n -> 新分区
t -> 类型设为 30（Linux LVM）, 20 为 Linux systemfile(原生文件系统如ext4)
w -> 写入

使用`fdisk -l /dev/vdb`检查分区情况可以看到：`/dev/vdb1 Type: Linux LVM`
但这里只是分区加标记

##### 2. 创建PV（Physical Volume）

PV 告诉 LVM 这块空间可以被我管理
创建: `pvcreate /dev/vdb1`
检查: `pvs(physical volume summary)/pvdisplay(更详细)`

##### 3. 创建VG（Volume Group）

把多个 PV 合并成一个「资源池」
扩容 = 往 VG 里再加 PV
创建VG: `vgcreate vg_data /dev/vdb1`
扩容VG: `vgextend vg_data /dev/vdc1`
检查: `vgs`

##### 4. 创建LV（Logical Volume）

LV 才是真正用来格式化和挂载的, 用起来就像普通分区一样

创建LV: `lvcreate -n lv_data -l +100%FREE vg_data`
-L = Logical volume size: 指定绝对大小
-l: 指定百分比大小
扩容LV: `lvextend -L 100G /dev/vg_data/lv_data`
检查: `lvs`

##### 5. 创建文件系统并挂载

```bash
mkfs.ext4 /dev/vg_data/lv_data
mkdir /data
mount /dev/vg_data/lv_data /data
df -h /data
```

### 各种文件相关概念

#### 文件系统（filesystem）

含义: 如何在 块(block) 上组织文件的规则
职责:

- inode（文件身份）
- block 分配
- 目录结构
- 权限
- 日志
- 崩溃恢复

##### inode

inode（index node）是文件系统中，用来描述“一个文件是什么”的数据结构
inode 不存文件内容, 存的是“文件的元信息 + 数据在哪”

典型 ext4 的 inode 包含这些信息：

- 元数据（metadata）
  - 文件类型（普通文件 / 目录 / 软链接 / 设备文件…）
  - 文件权限（rwx）
  - 所有者 UID / GID
  - 文件大小
  - 时间戳
    - atime（访问）
    - mtime（内容修改）
    - ctime（元数据修改）
  - 硬链接数量（link count）
- 数据位置
  - 文件内容所在的 block 地址
    - 直接块（direct）
    - 间接块（indirect）
    - 二级 / 三级间接块

inode 里面没有文件名, 而存放在目录里

目录本质是一个存放`文件名 -> inode 号`的映射表

#### 挂载点

挂载点只是一个目录, 标识把文件系统接入到目录树上的哪个位置

## bash

腾讯云会有自动配置一些东西

问题:
但是这个智算云的bash连ps1都是白色的, 太难看了, 只好手动修改一下
这似乎是因为我连接的是root用户, 新建了用户就好了

解释:
研究了一下发现是root的 bashrc 当中设置终端应用颜色的时候, 条件为 `$TERM=xterm-color`, 但是`echo $TERM`会发现许多终端都是`xterm-256color`, 加上了这个类型就可以看到颜色了
但是在 普通用户中的时候, 会因为 bashrc 没有对应设置, 所以使用了全局配置`/etc/bash.bashrc`, 全局配置里面只要非 sudo_user 就会显示颜色, 所以新建用户可以正常显示颜色

感想:
反而只有老式的终端界面能吃到这个`$TERM=xterm-color`的条件给 root 显示颜色, 结果现代的终端用太多, 以至于有点觉得 root 用户就是没颜色的, 以示特权

### 步骤

打开 ~/.bashrc 文件：
找到或添加 PS1 变量。例如默认是：
`PS1='\u@\h:\w\$ '`

\u → 用户名
\h → 主机名
\w → 当前路径

给用户名加颜色：
PS1='\[\e[31m\]\u\[\e[0m\]@\h:\w\$ '

\e[31m → 红色
\e[32m → 绿色
\e[33m → 黄色
\e[34m → 蓝色
\e[0m → 恢复默认颜色

这里的 \[\e[XXm\] 是 Bash 的颜色转义序列，前面加 \[ 和 \] 可以避免提示符长度计算错误。

保存并生效：

source ~/.bashrc

示例：绿色用户名主机名、蓝色路径：
`PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$'`

## 用户

linux 下的用户管理也比较神秘
推荐用户设置策略

| 用户类型               | 说明       | 建议                                       |
| ---------------------- | ---------- | ------------------------------------------ |
| root                   | 系统管理员 | 禁止直接 SSH 登录（安全），只在必要时 sudo |
| dev / ubuntu / student | 普通用户   | 日常操作、训练脚本、数据管理               |
| data                   | 数据管理   | 只读/写数据盘权限，限制登录范围（可选）    |
| service                | 运行服务   | 例如数据库、训练服务，权限最小化           |

### 查看用户

一般可以通过`ls /home`来查看有哪些普通用户的, 但由于用户目录其实可以被放到其他地方甚至也可以不创造用户目录

通过`cat /etc/passwd`可以看到系统中的所有用户
格式: `用户名:x(密码占位):UID:GID(用户组):描述(,,,为空):用户目录:默认Shell(类似于启动程序入口)`
UID >= 1000 → 普通用户
UID < 1000 → 系统用户
实际上你在`/etc/passwd`会看到大量条目, 例如:

```bash
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
...
```

这些大部分都是权限最小化, 用于运行特定服务或守护进程的系统用户
不可登录、也不可直接用来操作系统, UID 小于 1000（或者特定范围）, shell 大多是`/usr/sbin/nologin`

- /bin/bash: 最常见交互 shell
- /bin/sh: 兼容 shell
- /bin/zsh: 功能更强（mac 常用）
- /usr/sbin/nologin: 禁止交互
- /bin/false: 立即退出

所以可以通过`getent passwd | grep -v nologin`来反选筛选

### 新增用户

推荐用 adduser 而不是 useradd，因为 adduser 更人性化，默认会设置家目录、shell 等。
新增用户:`sudo adduser xxx`
删除用户:`sudo userdel -r xxx`, -r 会同时删除 /home/username 目录和邮件池, 否则只删除账号, 文件数据仍在。

#### 设置 sudo 权限

使用`id`命令可以查看当前用户的分组, 如果该用户在sudo组内则可以进行sudo

```bash
# 非sudo组
uid=1000(dev) gid=1000(dev) groups=1000(dev)
# sudo组
uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),27(sudo)
```

如果这个用户需要执行管理操作：`sudo usermod -aG sudo xxx`(usermod用于修改用户信息)
-aG sudo → 添加到 sudo 组
用户可以用 sudo 执行管理员命令
安全原则：不要给不可信用户 root 权限

#### 设置 SSH 登录

可选择使用密码或公钥登录, 虽然公钥不用总是输入密码无感链接很爽, 但事实是服务器密码设置比较复杂, 太久不用就忘了, 还是常常输入加强记忆吧
确保用户有家目录 /home/xxx

公钥登录
创建目录：
mkdir /home/xxx/.ssh
chmod 700 /home/xxx/.ssh

上传公钥：

nano /home/xxx/.ssh/authorized_keys
chmod 600 /home/xxx/.ssh/authorized_keys
chown -R xxx:xxx /home/xxx/.ssh

测试 SSH 登录

### 切换用户

`su - 用户名`或`su 用户名`
这其中似乎有些许差别, 留待探究

## 权限

linux中的读写权限执行权限需要手动赋予, 和win当中似乎不太一样
新文件默认为 666, 新目录则为 777

### 怎么查看权限

权限样式: `[0] [1][2][3] [4][5][6] [7][8][9]`

| [0]字符 | 含义              |
| ------- | ----------------- |
| `d`     | 目录（directory） |
| `-`     | 普通文件          |
| `l`     | 软链接            |
| `c`     | 字符设备          |
| `b`     | 块设备            |
| `p`     | 管道              |
| `s`     | socket            |

后九位三位为一组, 可以进行不同组合的分层管理
666(rw-), 777(rwx)的写法则是把同一组内看作二进制数字得到的

```text
rwx | r-x | r--
 ↑     ↑     ↑
owner group other
```

### 修改权限

`chmod 权限数字 文件名`

## vscode remote ssh

### 使用code命令

`code .`可以打开该文件夹为工作区
使用`-r = --reuse-window`参数可以在当前窗口打开
`code ./a.txt`可以打开文件到编辑器

## 软件包下载与各种镜像

软件包下载往往十分麻烦, 限速, 地区, 各种问题

### 软件源

查看软件源: `cat /etc/apt/sources.list`

常用的源:

```bash
deb http://archive.ubuntu.com/ubuntu jammy main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse
deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse
```

## 代理配置

许多时候服务器需要联外网, 但是却没有办法直连
所以这个时候就需要进行代理的配置

### 方式 1：SSH 端口转发 + HTTP(S) 代理

这是最干净、最可控、最不污染服务器环境的方式。

首先需要转发本地端口给服务器
VS Code 里面自带的 端口转发(Port Forwarding) 面板只能实现服务器->本地的代理, 无法实现本地->服务器的反向代理

编辑 VS Code 里本地的 SSH 配置文件：`~/.ssh/config`
加上SSH 参数：

```text
Host myserver
    HostName your_server_ip
    User ubuntu
    RemoteForward 7890 127.0.0.1:7890
```

效果等价于：`ssh -R 7890:127.0.0.1:7890 ubuntu@your_server_ip`

然后在服务器里设置代理环境变量

```bash
# export 只在当前shell生效, 相对比较安全
export http_proxy=http://127.0.0.1:7890
export https_proxy=http://127.0.0.1:7890
```

使用 curl 测试是否通了`curl https://huggingface.co -I`
`-I = --head`只发送 HTTP HEAD 请求，不下载 body, 不会浪费太多的服务器流量

### 方式 2（最暴力）：给 Python 单独指定代理

只影响 Python 进程：

```bash
HTTP_PROXY=http://127.0.0.1:7890 \
HTTPS_PROXY=http://127.0.0.1:7890 \
python your_script.py
```

或者在代码里（不推荐长期用）：

```py
import os
os.environ["http_proxy"] = "http://127.0.0.1:7890"
os.environ["https_proxy"] = "http://127.0.0.1:7890"
```

## 环境变量

在使用各种命令的时候常常可以看见修改环境变量使用镜像加速的操作
例如 huggingface 就可以通过设置一个 $HF_ENDPOINT 的变量来配置下载地址, 可以配置镜像加速

相关原理:
因为命令的 SDK 代码中对调用环境变量来动态决定一些 API 的入口地址
也因为环境变量 易于配置, 跟着进程自动切换 的特点, 所以 Docker, CI/CD, 各种SDK都爱用

### 环境变量的储存

环境变量不是文件，也不是配置项

环境变量：

不在 /etc
不在 /usr
不写进 ELF 程序

它存在于：进程的内存中
每个进程都有一份自己的环境变量表。

## 服务器硬件资源管理

怎么 24G 显存也爆了, 看来我需要进一步学习怎么查看并控制服务器的资源
